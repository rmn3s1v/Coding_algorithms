**FIRST BLOCK**
1. probability.py          - Собрать статистику об источнике, чтобы построить вероятностную модель этого источника.
2. entropy.py              - На основе двух подходов к измерению информации, оценить энтропию H(Xn), энтропию на букву источника Hn(X), и условную энтропию H(X| Xn-1) для букв, пар букв, троек букв (т.е. при n = 1, 2, 3).
3. Huffman_сode.py         - Построить код Хаффмена для букв, пар букв, троек букв. Составить таблицы. Оценить среднюю длину кодовых слов и среднюю скорость неравномерного кодирования двоичным кодом в каждом из трех случаев.
4. Shannon_сode.py         - Построить код Шеннона для букв, пар букв, троек букв. Составить таблицы. Оценить среднюю длину кодовых слов и среднюю скорость неравномерного кодирования двоичным кодом в каждом из трех случаев.
5. Gilbert_Moore_code.py   - Построить код Гилберта-Мура для букв, пар букв, троек букв. Составить таблицы. Оценить среднюю длину кодовых слов и среднюю скорость неравномерного кодирования двоичным кодом в каждом из трех случаев.
6. Result_of_FirstBlock.py - Собрать статистику об источнике, чтобы построить вероятностную модель этого источника.

**SECOND BLOCK**
1. Huffman_code_two_pass_V1.py / Huffman_code_two_pass_V2.py - Построить двухпроходное побуквенное кодирование с использованием кода Хаффмана (список кодовых слов, список длин кодовых слов, дерево). Составить таблицу.
                                                               Построить кодовое слово (c2(x)) для заданного текста.
                                                               Построить кодовую последовательность c1(x) - служебную информацию об использованном коде – для этого пометить “0” внутренние вершины дерева кода Хаффмана,
                                                               “1” – концевые вершины; считывать символы, приписанные вершинам ярус за ярусом, начиная с корня дерева, сверху вниз.
                                                               Оценить количество бит для передачи служебной информации (l1(x)) и закодированной последовательности (l2(x)).
2. Huffman_code_two_pass_regular.py                          - Построить двухпроходное побуквенное кодирование с использованием регулярного кода Хаффмана (список кодовых слов, список длин кодовых слов, дерево).
                                                               Построить бинарное дерево регулярного кода Хаффмана. Построить таблицу кодовых слов и служебную таблицу-информацию об использованном коде.
                                                               Записать кодовое слово (c2(x)) для заданного текста.
                                                               Оценить количество бит для передачи служебной информации (l1(x)) и закодированной последовательности (l2(x)).
3. stack_of_books_method.py                                  - Закодировать данное сообщение с использованием метода “Стопка книг”. Построить таблицу интервалов и кодовых слов. Записать сообщение в закодированном виде с(x).
                                                               Оценить количество бит для передачи закодированной последовательности l(x).
4. LZ77.py                                                  - Закодировать данное сообщение с использованием метода LZ-77. Создать словарь (занести данные в таблицу). Оценить количество бит для передачи закодированной последовательности l(x).
5. Resul_of_SecBlock.py                                     - Построить двухпроходное побуквенное кодирование с использованием кода Хаффмана (список кодовых слов, список длин кодовых слов, дерево).
                                                               Составить таблицу. Построить кодовое слово (c2(x)) для заданного текста. Построить кодовую последовательность c1(x) - служебную информацию об использованном
                                                               коде – для этого пометить “0” внутренние вершины дерева кода Хаффмана,
                                                               “1” – концевые вершины; считывать символы, приписанные вершинам ярус за ярусом, начиная с корня дерева, сверху вниз.
                                                               Оценить количество бит для передачи служебной информации (l1(x)) и закодированной последовательности (l2(x)).
