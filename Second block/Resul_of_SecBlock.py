from prettytable import PrettyTable
from math import *

# line = 'НЕ_ИМЕЙ_СТО_РУБЛЕЙ,_А_ИМЕЙ_СТО_ДРУЗЕЙ.'
# line = "там_королевич_мимоходом_пленяет_грозного_царя._у_наших_ушки_на_макушке!_чуть_утро_осветило_пушки_и_леса_синие_верхушки_-_французы_тут_как_тут."
# line = "Там_ступа_с_Бабою_Ягой_идёт,_бредёт_сама_собой._Два_дня_мы_были_в_перестрелке._Что_толку_в_этакой_безделке?_Мы_ждали_третий_день."
line = "и_тридцать_витязей_прекрасных_чредой_из_вод_выходят_ясных,_и_с_ними_дядька_их_морской._и_вот_нашли_большое_поле:_есть_разгуляться_где_на_воле!_построили_редут."

# Формируем столбцы таблицы
#------------------------------------------------------------------------------------------------------------------------
table = PrettyTable()
table.field_names = ["Номер шага", "Словарь", "№ слова", "Кодовое слово", "Затраты в битах"]
table.add_row([0, "#", "-", "-", "-"])
#------------------------------------------------------------------------------------------------------------------------

# Формируем ASCII код
#------------------------------------------------------------------------------------------------------------------------
array_of_ascii = []
array_of_symbol = []
for char in line:
    array_of_ascii.append(''.join(bin(c)[2:].rjust(8, '0') for c in char.encode('cp1251')))
    # array_of_ascii.append(ord(char.encode('cp1251')))
    array_of_symbol.append(char)
#------------------------------------------------------------------------------------------------------------------------

dictionary = [] # словарь символов
array_of_step = [] # массив шагов для символов
memorry = 0 # общий объем затраченных бит
skip = 1 # переменная для пропуска ненужных символов

# Основной алгоритм
#------------------------------------------------------------------------------------------------------------------------
for index in range(len(line)): # проходим по всем символам строки
    if skip == 1: # елси нечего пропускать
        if line[index] in dictionary: # проверяем наличие символа в словаре
            next_symbol = 1 # добавочный индекс для просмотра следующих символов

            while line[index:index + next_symbol] in dictionary and index + next_symbol <= len(line): # пока в нашем словаре есть встречающаяся последовательность
                next_symbol += 1 # увеличиваем добавочный индекс для просмотра следующего символа

            if len(line[index:index + next_symbol]) > 2: # если длина последовательности больше 2, то нужно пропустить нексколько символов
                skip = len(line[index:index + next_symbol]) - 1

            for step_of_elements in range(len(dictionary) - 1, -1, -1): # перебираем все последовательности словаря, для нахождения последнего вхождения текущей последовательности
                if dictionary[step_of_elements] == line[index:index + next_symbol - 1]: # нашли совпадение
                    array_of_step.append(step_of_elements + 1) # добавили номер шага, на котором встретилось последнее повторение
                    break

            dictionary.append(line[index:index + next_symbol]) # добавили в словарь последовательность

        else: # если символ не встречался
            array_of_step.append(0) # добавляем 0, так как не было шага, на котором встретился символ
            dictionary.append(line[index]) # добавляем его текущий шаг, так как он нам встретился

    else: # если есть, что пропускать, то пропускаем
        skip -= 1
#------------------------------------------------------------------------------------------------------------------------

# Формируем табоицу
#------------------------------------------------------------------------------------------------------------------------
for i in range(len(dictionary)): # проходимся по всем символам словаря
    code = "" # переменная, которая хранит в себе код

    if array_of_step[i] == 0: # если шаг = 0
        if i == 0: # проверка на математику (т.к нельзя взять логарифм от 0)
            code = array_of_ascii[array_of_symbol.index(dictionary[i])]

        else: # формируем бинарный код по правилу
            code = '0' * ceil(log2(i)) + array_of_ascii[array_of_symbol.index(dictionary[i])]

    else: # если же шаг != 0
        len_code = ceil(log2(i)) # длина кодового слова
        bin_code = bin(array_of_step[i])[2:] # двоичный код шага
        code = '0' * (len_code - len(bin_code)) + bin_code # результат кодового слова

    table.add_row([i + 1, dictionary[i], array_of_step[i], code, len(code)]) # добавляем строку в таблицу
    memorry += len(code) # увеличиваем затраты бит
#------------------------------------------------------------------------------------------------------------------------

print(table) # выводим таблицу
print(f"l = {memorry}") # выводим общее кол-во затрат в битах
